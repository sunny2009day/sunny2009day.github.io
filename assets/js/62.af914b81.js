(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{326:function(e,t,a){"use strict";a.r(t);var s=a(5),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"javascript-的运行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的运行机制"}},[e._v("#")]),e._v(" JavaScript 的运行机制")]),e._v(" "),a("ul",[a("li",[e._v("代码是"),a("code",[e._v("CPU")]),e._v("执行的,js是一种解释型的动态"),a("strong",[e._v("单线程")]),e._v("语言,跨平台,即时编译,也不会有目标代码生成。这个过程通常由宿主环境（如浏览器、Node.js）包办。")]),e._v(" "),a("li",[e._v("浏览器进程(进程process计算机分配任务和调度的最先单位)，一个进程可以包括多个线程,js是线程执行的,并且"),a("strong",[e._v("JavaScript 是单线程语言")]),e._v("，Web-Worker 还是 node 里面的cluster创造多线程环境,内部都是单线程执行，而且 cluster 还是进程管理相关；")]),e._v(" "),a("li",[e._v("单线程模型,即所有任务只能在一个线程上完成,前面的任务没做完,后面的任务只能等着;"),a("code",[e._v("js")]),e._v("的单线程形成了一个浏览器事件环, 主线程只有一个 "),a("code",[e._v("setTimeout")]),e._v(", "),a("code",[e._v("ajax")]),e._v(", "),a("code",[e._v("setInterval")]),e._v(", "),a("code",[e._v("requestFrameAnimation")]),e._v("事件， 事件环来实现任务的调度")]),e._v(" "),a("li",[e._v("js 基本分组成 ： (BOM DOM) ECMAScript (es6模块) 模块的特性 api包 帮你实现文件操作服务器端的创建")]),e._v(" "),a("li",[e._v("单线程的优点\n1> 高并发\n2> 适合i/o密集\n3> 解决切换上下文时间,锁的问题,节省内存")]),e._v(" "),a("li",[e._v("单线程的缺点\n1> 不适合cpu密集\n2> 易阻塞")])]),e._v(" "),a("h2",{attrs:{id:"进程和线程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[e._v("#")]),e._v(" 进程和线程的区别")]),e._v(" "),a("ul",[a("li",[e._v("一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等,进程表示一个程序，线程是进程中的单位 ,主线程只有一个")]),e._v(" "),a("li",[e._v("1个进程可以占用1核cpu ，node可以（开 4 - 32个子进程）")]),e._v(" "),a("li",[e._v("多线程在单核cpu中其实也是顺序执行的，不过系统可以帮你切换那个执行而已，没有提高速度")]),e._v(" "),a("li",[e._v("多个cpu的话就可以在多个cpu中同时执行")])]),e._v(" "),a("h2",{attrs:{id:"nodejs的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs的应用"}},[e._v("#")]),e._v(" nodejs的应用")]),e._v(" "),a("ul",[a("li",[e._v("nodejs 是runtime可以让js运行在服务端上,单线程")])]),e._v(" "),a("ol",[a("li",[e._v("写脚本,中间层,服务端渲染(vue, react)可以实现前后端分离，例如服务端的eggs,nest")]),e._v(" "),a("li",[e._v("实现高性能的web服务")])]),e._v(" "),a("h2",{attrs:{id:"浏览器进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程"}},[e._v("#")]),e._v(" 浏览器进程")]),e._v(" "),a("blockquote",[a("p",[e._v("浏览器是计算机应用程序,每一个tab页都会启动新的主进程和GPU进程;\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-fe6f56706aa61140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})])]),e._v(" "),a("blockquote",[a("p",[e._v("js线程执行的事件huan\n"),a("strong",[e._v("event loop")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-da38087f03e05551.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"1573232016(1).jpg"}})]),e._v(" "),a("blockquote",[a("p",[e._v("同步任务和异步任务是广义的定义,更精细的是\n微任务： promise.then ，MutationObserver(监视对DOM树所做更改)，process.nextTick\n宏任务：script ，ajax ， 事件，requestFrameAnimation， setTimeout ，setInterval ，setImmediate （ie下），MessageChannel ，I/O ，UI rendering。")])]),e._v(" "),a("ul",[a("li",[e._v("同一event table下,微任务会比宏任务快，js中会先执行script脚本")])]),e._v(" "),a("h4",{attrs:{id:"vue-nexttick-vue-dom渲染都是异步的-dom渲染原生的是同步的-vue中把dom渲染变成异步，nexttick放到异步回调之后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick-vue-dom渲染都是异步的-dom渲染原生的是同步的-vue中把dom渲染变成异步，nexttick放到异步回调之后"}},[e._v("#")]),e._v(" vue.nextTick(vue dom渲染都是异步的),dom渲染原生的是同步的,vue中把dom渲染变成异步，nextTick放到异步回调之后")]),e._v(" "),a("p",[e._v("可在"),a("a",{attrs:{href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/"),a("OutboundLink")],1),e._v("\n执行异步同步事件有详细的讲解：如图:\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-dd37f135328b1793.gif?imageMogr2/auto-orient/strip",alt:"640.gif"}})]),e._v(" "),a("h2",{attrs:{id:"node事件执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node事件执行机制"}},[e._v("#")]),e._v(" node事件执行机制")]),e._v(" "),a("ul",[a("li",[e._v("Node 和浏览器的Event Loop是两个有明确区分的事物。nodejs的event是基于libuv，而浏览器的event loop则在html5的规范中明确定义。\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-9830cd70b975328f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})])]),e._v(" "),a("p",[e._v("Node 的 Event Loop 分为 6 个阶段：")]),e._v(" "),a("ol",[a("li",[e._v("timers：定时器,执行setTimeout() 和 setInterval()中到期的callback。")]),e._v(" "),a("li",[e._v("pending callback: 上一轮循环中有少数的I/O callback会被延迟到这一轮的这一阶段执行\n3 .idle, prepare：内部的一些准备操作\n4 .poll: 最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段")]),e._v(" "),a("li",[e._v("check: 执行setImmediate的callback,检查阶段")]),e._v(" "),a("li",[e._v("close callbacks: 执行close事件的callback，例如socket.on('close'[,fn])、http.server.on('close, fn)\n"),a("strong",[e._v("poll 的i/o操作,如果没有check会阻塞在这里等定时器到达*时间，如果有check会在轮训完毕后立即执行")])])]),e._v(" "),a("ul",[a("li",[e._v("process.nextTick拥有一个自己的队列,是优先于promise.then的微任务,当前promise微任务完成之后处理nextTickQueue,如果存在 nextTickQueue，就会清空队列中的所有回调函数(then,catch)，并且优先于其他 microtask 执行(执行一次微任务处理一次回调)。")]),e._v(" "),a("li",[e._v("setImmediate() 和 setTimeout()非常的相似执行时序受进程性能的限制;")])]),e._v(" "),a("h2",{attrs:{id:"node与浏览器的event-loop差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node与浏览器的event-loop差异"}},[e._v("#")]),e._v(" node与浏览器的event loop差异")]),e._v(" "),a("p",[a("strong",[e._v("浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。")]),e._v(" "),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-730829ffff64b37a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"1573301160(1).jpg"}}),e._v(" "),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/14983171-e6b4252c0399f5b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"1573303078(1).jpg"}})])])}),[],!1,null,null,null);t.default=i.exports}}]);